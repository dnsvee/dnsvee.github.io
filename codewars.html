<!-- Zebra/Einstein puzzle from Rosettacode -->
<html>
	<head>
		<meta title='CodeWars problems solutions'>
		<link rel='stylesheet' href='styles.css'>
		<style>
			.problem {
				display: flex;
				flex-flow: column wrap;
			}				
			
		</style>
	</head>
	<body>
		<a id='back' href='/index.html'>Back</a>
		<h1>Solutions to problems from CodeWars</h3>
		<p><a href='https://codewars.com/'>CodeWars</a> is another website featuring programming challenges where you can. Solutions are checked by running multiple test cases. Here are some of my solutions to a subset of problems I solved. Unfortunately you can't directly link to a solution and have it tested. I will present the source and link to the problem.</p>
				
		<div class='problem'>
		<p><a href='https://www.codewars.com/kata/58e24788e24ddee28e000053/java'>Simple assembler interpreter</a>
		<p>This is the first part of this kata series. Second part is here.

We want to create a simple interpreter of assembler which will support the following instructions:

mov x y - copies y (either a constant value or the content of a register) into register x
inc x - increases the content of the register x by one
dec x - decreases the content of the register x by one
jnz x y - jumps to an instruction y steps away (positive means forward, negative means backward, y can be a register or a constant), but only if x (a constant or a register) is not zero
Register names are alphabetical (letters only). Constants are always integers (positive or negative).

Note: the jnz instruction moves relative to itself. For example, an offset of -1 would continue at the previous instruction, while an offset of 2 would skip over the next instruction.

The function will take an input list with the sequence of the program instructions and will execute them. The program ends when there are no more instructions to execute, then it returns a dictionary with the contents of the registers.

Also, every inc/dec/jnz on a register will always be preceeded by a mov on the register first, so you don't need to worry about uninitialized registers.</p>
		<pre><code>
import java.util.*;
import java.io.*;

public class SimpleAssembler {  
  static Map<String, Integer> Regs;
  
  static public int getValueOrRegister(String s) {
      if (Character.isLetter(s.charAt(0))) 
        return Regs.get(s);
    
      return Integer.valueOf(s);
  }
  
  public static Map<String, Integer> interpret(String[] program){
    int ip = 0;

    Regs = new HashMap<String, Integer>();
    while (ip < program.length) {
      String[] strs = program[ip].split("\\s");
      
      switch (strs[0]) {
        case "mov":
          Regs.put(strs[1], getValueOrRegister(strs[2]));
          ip++;
          break;
        case "inc":
          Regs.put(strs[1], Regs.get(strs[1]) + 1);
          ip++;
          break;
        case "dec":
          Regs.put(strs[1], Regs.get(strs[1]) - 1);
          ip++;
          break;
        case "jnz":
          if (getValueOrRegister(strs[1]) != 0)
            ip += getValueOrRegister(strs[2]);
          else
            ip++;
          
          break;
        default:
          throw new RuntimeException("oh no!");
      }
    }
    
    return Regs;
  }
}
		</code></pre></div>
		

		
		

	</body>
</html>
